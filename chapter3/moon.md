## 객체 꾸미기 - 데코레이터 패턴

### OCP 살펴보기
- OCP(Open-Close Principle)은 정말 중요한 디자인 원칙 중 하나입니다.
- 디자인 원칙: 클래스는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다.

### 데코레이터 패턴 살펴보기
1. DarkRoast 객체를 가져온다.
2. Mocha 객체로 장식한다.
3. Whip 객체로 장식한다.
4. cose() 메소드를 호출한다. 이때 첨가물의 가격을 계산하는 일은 해당 객체에게 맡긴다.
- 여기서 객체를 어떻게 장식할 수 있을까?

### 주문 시스템에 데코레이터 패턴 적용하기
1. DarkRoast 객체에서 시작.
2. 고객이 모카를 주문했으니 Mocha 객체를 만들고 그 객체로 DarkRoast객체를 감싼다.
3. 고객이 휘핑크림도 주문했으니 Whip 객체를 만들어 Mocha 객체를 감싼다.
4. 가격을 계산할때는 DarkRoast, Mocha, Whip 3개의 객체가 각각 cost를 들고 있으니 바깥쪽부터 cost를 호출해 그 객체가 장식하고 있는 객체에 가격을 위임한다.

### 지금까지 배운내용 정리
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼 클래스와 같다.
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다.
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다.
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할수 있다.

### 데코레이터 패턴 정의
- 데코레이터 패턴으로 객체에 추가 요소를 유동 적으로 더할수 있다.
- 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
