## chapter1. 디자인 패턴의 세계로 떠나기
- 규격이 바뀔 때마다 프로그램에 추가했던 Duck의 서브클래스 fly()와 quack() 메서도를 일일이 살펴보고 상황에 따라 오버라이드해야 합니다.
- 코드 작업을 다시 하는 시간을 줄여 더 좋은 프로그램을 만드는 데 많은 시간을 투자할 수 있을 테니까요.
- 시간이 지남에 따라 변화하고 성장해야 합니다.
- 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는 방법을 제공하니까요.
- 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어넣습니다.
- 애초에 이런 문제에 말려든 게 오리의 행동과 관련된 유연성 때문이었으니까요.
- 행동 인터페이스는 Duck 클래스가 아니라 방금 설명한 행동 클래스에서 구현합니다.
- 상위 형식(supertype)에 맞춰 프로그래밍해서 다형성을 활용해야 한다는 점에 있습니다.
- 가장 중요한 점은 나는 행동과 꽤괙거리는 행동을 Duck 클래스(또는 그 서브클래스)에서 정의한 메소드를 써서 구현하지 않고 다른 클래스에 위임한다는 것입니다.
- Duck 클래스에 fly()와 quack() 대신 performFly()와 performQuack()이라는 메소드를 넣습니다.
- 오리의 행동들을 일련의 행동으로 생각하는 대신, 알고리즘군(family or algorithms)으로 생각하는 거죠.
- 여기에 나와 있는 오리 클래스에서는 행동을 상속받는 대신, 올바른 행동 객체로 구성되어 행동을 부여받습니다.
- 또한 자질구레한 객체 수준에서의 생각이 아닌, 패턴 수준에서 생각할 수 있기에 아키텍처를 생각하는 수준도 끌어올려 줍니다.
- 신입 개발자들에게는 디자인 패턴을 배울 동기가 부여됩니다.
- 디자인 패턴은 우선 여러분의 머릿속에 들어갑니다.
- 나중에 어떻게 바뀔 것인지 생각해 보는거죠.
