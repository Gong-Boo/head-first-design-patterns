# 어댑터 패턴과 퍼사드 패턴
- 어댑터는 한 인터페이스를 다른 인터페이스로 변환해 주는 역할을 합니다.
- 새로운 업체에서 사용하는 인터페이스를 기존에 사용하던 인터페이스에 적응시켜 주는 클래스를 만들면 됩니다.
- 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 하나 이상의 메소드 호출로 변환합니다.
- 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모릅니다.
- 클라이언트와 어댑티는 서로 분리되어 있습니다. 서로 전혀 모르죠.
- 타깃 인터페이스로 지원해야 하는 인터페이스의 크기에 비례해서 복잡해지죠.
- 이보다는 그냥 모든 변경 사항을 캡슐화할 클래스 하나만 제공하는 방법이 더 낫지 않을까요?
- 그런 상황에는 두 인터페이스를 모두 지원하는 다중 어뎁터를 만들면 됩니다.
- 어뎁터가 기존 인터페이스와 새로운 인터페이스 역할을 할 수 있게 하면 됩니다.
- 클라이언트에서 요구하는 다른 인터페이스로 변환합니다.
- 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와줍니다.
- 호환되지 않는 인터페이스를 사용하는 클라이언트를 그대로 활용할 수 있습니다.
- 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있다는 장점이 있습니다.
- 이렇게 인터페이스를 기준으로 코딩했기에 타깃 인터페이스만 제대로 유지한다면 나중에 다른 구현을 추가하는 것도 가능합니다.
- 모두 서브클래스로 만들어서 사용하고 객체 어댑터는 구성으로 어댑티에 요청을 전달한다는 점을 빼면 별 다를게 없습니다.
- 특정 어댑티 클래스에만 적용할 수 있다는 단점이 있죠.
- 어댑티 전체를 다시 구현하지 않아도 된다는 장점이 있어요.
- 어떤 클래스의 인터페이스를 클라이언트가 원하는 인터페이스로 변환하는 방법을 배웠습니다.
- 이 패턴은 인터페이스를 단순하게 바꾸려고 인터페이스를 변경하죠.
- 물론 복잡한 시스템을 직접 건드리고 싶다면 기존 인터페이스를 그래도 쓰면 됩니다.
- 서비시스템의 기능을 사용할 수 있는 간단한 인터페이스를 제공할 뿐이죠.
- 퍼사드의 개수에는 제한이 없습니다.
- 퍼사드만 바꾸면 됩니다 홈시어터 시스템을 ㅁ나드는 회사에서 퍼사드를 제공한다면 금상첨화겠죠?
- 클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않아도 되고 다음쪽에서 살펴볼 새로운 객체지향 원칙을 준수하는 데도 도움이 됩니다.
- 서브시틈에 있는 일련의 인터페이스를 통합 인터페이스로 묶어 줍니다.
- 아주 가까운 '친구' 사이에서만 허용하는 편이 좋습니다.
- 여러 클래스가 서로 복잡하게 의존하고 있다면 관리하기도 힘들고 남들이 이해하기 어려운 불안정한 시스템이 만들어집니다.
